---
title: "Modelle für Vorhersage optimieren"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Modelle für Vorhersage optimieren}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- __WORK IN PROGRESS__ -->

<!-- ```{r, include = FALSE} -->
<!-- knitr::opts_chunk$set( -->
<!--   collapse = TRUE, -->
<!--    comment = "#>", -->
<!--    message = FALSE, -->
<!--    warning= FALSE -->
<!--  ) -->
<!-- ``` -->

<!-- ```{r setup} -->
<!-- library(plausi) -->
<!-- library(caret) -->
<!-- library(tidyverse) -->
<!-- ``` -->

<!-- # Parameter-Tuning mit dem Caret package -->

<!-- ```{r} -->
<!-- # BFS Nummern ausgewählter Gemeinden -->
<!-- bfs_nrs <- c(6,7,10,11,12,87,219,294 ,181,38,60,92,119,182,218) -->

<!-- Sys.setenv(https_proxy="") -->
<!-- # Beziehe historische Daten -->
<!-- results <- swissdd::get_nationalvotes(from_date="2015-03-01", to_date="2020-11-29") -->

<!-- # Formattiere historische Daten um : eine Spalte je Vorlage -->
<!-- testdata <- results %>% -->
<!--   filter(canton_id==1) %>%  -->
<!--   mutate(id=paste0("v",id)) %>% -->
<!--   dplyr::select(jaStimmenInProzent, id, mun_id, mun_name) %>% -->
<!--   pivot_wider(names_from=id, values_from = jaStimmenInProzent) %>%  -->
<!--   drop_na() -->

<!-- traind <- testdata %>%  -->
<!--   mutate_at(vars(v6360),# vars(v6360,v6370), -->
<!--             ~ifelse(mun_id %in% bfs_nrs,., NA)) %>%  -->
<!--   drop_na() -->

<!-- svmGrid <- expand.grid(sigma= 2^c(-25, -20, -15,-10, -5, 0), C= 2^c(0:5)) -->

<!-- svm_mod <- train( -->
<!--   v6360 ~ .,  -->
<!--   data = traind %>% dplyr::select(-mun_id,-mun_name), -->
<!--   method = "svmRadial",                -->
<!--   trControl = trainControl(method = "cv", number = 10), -->
<!--   tuneGrid = svmGrid, -->
<!--   tuneLength = 10 -->
<!-- ) -->

<!-- svm_mod -->


<!-- svm_mod$results -->

<!-- ggplot(svm_mod) +  -->
<!--   theme_light() -->


<!-- testdata$newpred <- predict(svm_mod, testdata) -->

<!-- testdata %>% select(mun_id,mun_name, v6360,newpred) -->
<!-- ``` -->

<!-- # Paramter-Tuning mit dem plausi-package -->
<!-- Das Tuning-Grid kann den Funktionen des plausi-packages ebenfalls übergeben werden. -->
<!-- ```{r} -->
<!-- # works -->
<!-- predict_single_vote("v6360", -->
<!--                     traindata=traind,  -->
<!--                     testdata=testdata, -->
<!--                     method="svmRadial", -->
<!--                     geovars=c("mun_id","mun_name" ), -->
<!--                     tuneGrid=svmGrid, -->
<!--                     tuneLength = 10) -->

<!-- # working - dots are now passed as intended -->
<!-- predict_votes(votes=c("v6360"), -->
<!--                     train=traind,  -->
<!--                     test=testdata, -->
<!--                     method="svmRadial", -->
<!--                     geovars=c("mun_id","mun_name"), -->
<!--                     tuneGrid=svmGrid, -->
<!--                     tuneLength = 10) -->

<!-- ``` -->

```{r echo=FALSE}





# # Hier code einbauen der nur Vorlagen mit mehr als 5-10 einträgen aufweist
# 
# pred_all <- pred_act %>% 
#   filter(gemwkid != 9010)%>% 
#   rename(v_gemwkid = gemwkid)%>% 
#   # allenfalls auf right-join umstellen
#   right_join(features, by = c("v_gemwkid")) %>% 
#   #hack um gemeindelabels für Gemeinden die noch nicht auf gelb sind beizubehalten
#   mutate(gemeinde=v_gemeinde) %>% 
#   select(-v_gemeinde)
# 
# 
# loocv <- caret::trainControl(method = "LOOCV", number = 10)
# cv10 <- caret::trainControl(method = "cv", number = 10)
# 
# earth <- 
#   cv_model_mars <- caret::train(
#     Eidg3 ~ ., 
#     data = pred_all %>% select(-gemeinde, -v_gemwkid) %>% drop_na(),
#     method = "gcvEarth",
#     trControl = loocv
#   )
# 
# glm <- 
#   cv_model_mars <- caret::train(
#     Eidg3 ~ ., 
#     data = pred_all %>% select(-gemeinde, -v_gemwkid) %>% drop_na(),
#     method = "glmnet",
#     trControl = cv10
#   )
# 
# tox_svm <- train(  Eidg3 ~ ., 
#     data = pred_all %>% select(-gemeinde, -v_gemwkid) %>% drop_na(),
#                  method = "svmRadial", 
#                  metric = "wRMSE",
#                  maximize = FALSE,
#                  tuneLength = 10,trControl = cv10)
# 
# 
# tg <- expand.grid(shrinkage = seq(0.1, 1, by = 0.2), 
#                   interaction.depth = c(1, 3, 7, 10),
#                   n.minobsinnode = c(2, 5, 10),
#                   n.trees = c(100, 300, 500, 1000))
# 
# gbm <- 
#   cv_model_mars <- caret::train(
#     Eidg3 ~ ., 
#     data = pred_all %>% select(-gemeinde, -v_gemwkid) %>% drop_na(),
#     method = "ranger",
#     trControl = cv10
#   )
# 
# 
# mods <- resamples(list(earth=earth2, svm=tox_svm, glm=glm,ranger=gbm))
# 
# summary(mods)

```

```{r echo=FALSE}

# Overfitting / Robustness to errors & anomalies

# with real data 
# 
# # Solve Overfitting
# https://blog.zenggyu.com/en/post/2018-06-16/multivariate-adaptive-regression-splines-in-a-nutshell/
# 
# ```{r}
# 
# sundata_369 <- readRDS("C:/gitrepos/plausi/data/20200927/sundata_369.RDS")
# 
# features <- readRDS("C:/gitrepos/plausi/data/20200927/features2020-09-27.RDS")
# 
# unique(sundata_369$gemwkid)
# 
# # wide to long
# pred_act <- sundata_369 %>% 
#   select(gemeinde,gemwkid, artsort, jastimmeninprozent) %>% 
#   tidyr::spread(artsort,jastimmeninprozent)
# 
# # Hier code einbauen der nur Vorlagen mit mehr als 5-10 einträgen aufweist
# 
# pred_all <- pred_act %>% 
#   filter(gemwkid != 9010)%>% 
#   rename(v_gemwkid = gemwkid)%>% 
#   # allenfalls auf right-join umstellen
#   right_join(features, by = c("v_gemwkid")) %>% 
#   #hack um gemeindelabels für Gemeinden die noch nicht auf gelb sind beizubehalten
#   mutate(gemeinde=v_gemeinde) %>% 
#   select(-v_gemeinde)
# 
# # ControlParamteres <- caret::trainControl(method = "cv",
# #                                   number = 5,
# #                                   savePredictions = TRUE,
# #                                   classProbs = TRUE)
# # 
# # 
# # parameterGrid <- expand.grid(mtry=c(2,3,4))
# # 
# 
# pred_all <- pred_all %>% mutate(Eidg3=ifelse(gemeinde=="Rüti", 66, Eidg3))
# 
# # hyper_grid <- expand.grid(
# #   degree = 1:3,
# #   nprune = seq(2, 100, length.out = 10) %>% floor()
# # )
# 
# yes_out<-pred_all %>% mutate(yes_out=is_outlier_double_mad(Eidg3)) %>% filter(yes_out==TRUE)
# 
# 
# 
# # Methode von gcvEarth auf pls angepasst
# preddata <- predict_votes(votes = colnames(pred_act)[c(-1,-2)], 
#                           train = pred_all, 
#                           method = "gcvEarth",
#                           trControl = trainControl(method = "repeatedcv", number = 10, repeats = 5),
#                           # tuneGrid=hyper_grid,
#                           exclude_votes = TRUE) %>% 
#                   mutate(differenz = abs(real - pred)) %>% 
#                   mutate_if(is.numeric,~round(.,1)) %>% 
#                   rename(Gemeinde=gemeinde)
# 
# 
# 
# preddata %>% 
#        group_by(vorlage) %>% 
#        summarize(rmse=RMSE(pred,real,na.rm=TRUE))
# 
# 
# preddata2 <- predict_votes(votes = colnames(pred_act)[c(-1,-2)], 
#                           train = pred_all, 
#                           method = "svmRadial",
#                           # method="bagEarth",
#                            # method = "earth",
#                           # trainControl = ControlParamteres,
#                           tuneGrid=glmBoostGrid,
#                           exclude_votes = TRUE) %>% 
#                   mutate(differenz = abs(real - pred)) %>% 
#                   mutate_if(is.numeric,~round(.,1)) %>% 
#                   rename(Gemeinde=gemeinde)
# 
# preddata2 %>% 
#        group_by(vorlage) %>% 
#        summarize(rmse=RMSE(pred,real,na.rm=TRUE))
# 
# 
# preddata2 %>% 
#   filter(Gemeinde=="Rüti")
# 
# 
# preddata3<-preddata2 %>% 
#   bind_rows(preddata) %>% 
#   group_by(Gemeinde, v_gemwkid, vorlage) %>% 
#   summarize_at(vars(pred,real), mean)%>% 
#                   mutate(differenz = abs(real - pred)) %>% 
#                   mutate_if(is.numeric,~round(.,1)) 
# 
# preddata3 <- preddata3 %>% 
#   group_by(vorlage) %>% 
#   mutate(rmse=RMSE(pred,real,na.rm=TRUE)) %>% 
#   mutate(potential_error=differenz/rmse)
# 
# 
# preddata3 %>% 
#        group_by(vorlage) %>% 
#        summarize(rmse=RMSE(pred,real,na.rm=TRUE))
#                   
# 
# preddata %>% 
#   filter(Gemeinde=="Rüti")



```


<!-- # Modelle vergleichen -->

<!-- Plausi baut auf dem caret-package auf und lässt es somit zu, zwischen unzähligen Machine-Learning Algorithmen zu wählen und einfach umzustellen. Dies erleichtert es Modelle hinsichtlich Vorhersagegenauigkeit zu vergleichen. -->

<!-- Das 'gvcEarth' Model, ein MARS-Modell aus dem 'earth' package (Splines) wie auch ein svm-Modell schneiden am besten ab. Doch neben der Vorhersagegenauigkeit sollte das Modell auch möglichst robust gegenüber einzelnen vermeintlich falschen Resultaten sein bzw. diese sollten die Vorhersage für eine Gemeinde nicht zu stark beeinflussen. -->

<!-- - gcvEarth offers the best accuracy, however seems to be prone to overfit in case of false results (real example: Rüti with switched yes and no-shares) -->
<!-- - svmRadial is a bit less acurate on average however seems not to be affected by single false results -->

<!-- ```{r define models} -->
<!-- # Modelle die verglichen werden sollen -->
<!-- models <- c("gcvEarth","glmboost","pls","pcr","svmRadial") -->

<!-- # Funktion für Vergleich unterschiedlicher Modelle -->
<!-- test_models <- function(votes, train,test, model,...){ -->


<!-- plausi::predict_votes(votes = votes,  -->
<!--                           train = train, -->
<!--                           test=test, -->
<!--                            method = model, -->
<!--                           exclude_votes = TRUE, -->

<!--               ...) %>%  -->
<!--     dplyr::mutate(mod=model)  -->



<!-- } -->

<!-- #Vergleich anhand der Vorhersage für drei Vorlagen -->
<!-- comparison <- map_dfr(models, ~test_models(votes=colnames(train)[c(-1,-2)][1:3], -->
<!--                                         train=train, -->
<!--                                         test=testdata, -->
<!--                                         model=.x, -->
<!--                                         geovars=c("mun_id","mun_name"))) -->

<!-- # Vorhersagefehler je Modell pro Vorlage -->
<!-- comparison %>%  -->
<!--   group_by(vorlage,mod) %>%  -->
<!--   summarize(rmse=RMSE(pred,real,na.rm=TRUE)) -->


<!-- ``` -->



---
title: "Ja-Anteile plausibilisieren"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Ja-Anteile plausibilisieren}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE, 
  message = FALSE) 
```

Die Stabilität des Abstimmungsverhaltens der Gemeinden ist aus Sicht Plausibilisierung ein echter Glücksfall. Die ideologische Ausrichtung einer Gemeinde ändert sich oft nur sehr langsam. Das eröffnet die Möglichkeit, auf Basis vergangener Abstimmungen Vorlagen zu identifizieren, die ähnliche Zustimmungsmuster aufweisen wie die aktuellen Abstimmungsvorlagen. An einem laufenden Abstimmungssonntag können wir so präzise Vorhersagen treffen und simulieren, welche Ergebnisse aufgrund der historischen Daten zu erwarten wären.

```{r setup}
# Installiere das "swissdd"-Package um die Abstimmungsdaten von opendata.swiss zu beziehen
devtools::install_github("politanch/swissdd")

library(plausi)
library(tidyr)
library(dplyr)
library(swissdd)
library(caret)
library(kernlab)

# BFS Nummern ausgewählter Gemeinden
bfs_nrs <- c(6,7,10,11,12,87,219,294,181,38,60,92,119,182,218,261)

# Sys.setenv(https_proxy="")
```


```{r}
# Beziehe historische Daten
results <- swissdd::get_nationalvotes(from_date="2017-03-01", to_date="2020-09-27")

# Füge einen künstlichen Fehler ein 
 results<- results %>%
            mutate(jaStimmenInProzent=ifelse(mun_id==7 & id == 6310, jaStimmenInProzent+15, jaStimmenInProzent))

# Formattiere historische Daten um ins Wide-Format (=eine Spalte je Vorlage)
testdata <- results %>%
  filter(canton_id==1 & mun_id %in% bfs_nrs) %>% 
  mutate(id=paste0("v",id)) %>%
  select(jaStimmenInProzent, id, mun_id, mun_name) %>%
  pivot_wider(names_from=id, values_from = jaStimmenInProzent) %>% 
  drop_na()

# Gewisse Gemeinden sind etwas schwerer hervorzussagen - wenn sie 'extreme sind'. 
# Upsampling für höheres Gewicht! 

traindata <- testdata %>%
        mutate(ntimes = ifelse(mun_id %in% c(261, 12), 3, 1)) 

traindata <- as_tibble(lapply(traindata, rep, traindata$ntimes)) %>%
        select(-ntimes)

# Sage Resultate vorher
predicted_results <- predict_votes(c("v6350","v6310"),
                                   train=traindata, 
                                   test=testdata,
                                   method = "svmRadial",
                                   exclude_votes = TRUE, 
                                   geovars=c("mun_id","mun_name" ))

# Mittlerer Vorhersagefehler (RMSE) pro Vorlage
predicted_results %>% 
  group_by(vorlage) %>% 
  summarize(rmse=RMSE(pred,real))
```


```{r}
# Berechne Abweichung des gemeldeten Resultats von der Vorhersage und kennzeichne Werte, die mehr als drei durchschnittliche Vorhersagefehler von der Vorhersage abweichen als auffällig
# Auffällige Ja-Anteile weichen über drei mittleren Vorhersagefehlern von der Vorhersage ab
gem_pred <- predicted_results%>% 
  mutate(error=real-pred) %>% 
  group_by(vorlage) %>% 
  mutate(rmse=RMSE(pred,real)) %>% 
  mutate(error_rmse=error/rmse) %>%   
  mutate(outlier=error_rmse>3)

# Knonau mit dem künstlichen Fehler wird als auffällig gekennzeichnet
gem_pred %>% filter(outlier==TRUE)

# Grafische Darstellung
ggplot(gem_pred, aes(vorlage,real))+
  geom_point(aes(color=outlier))+
  geom_violin(alpha=0.5)+
  scale_color_viridis_d()+
  theme_minimal()
```
